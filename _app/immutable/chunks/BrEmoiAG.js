class n{static new(t,s,e,a){return{task:t,start:s,end:e,qType:a}}static intersects(t,s){const[e,a]=n.getTimestamp(t.start),[i,r]=n.getTimestamp(t.end),[u,o]=n.getTimestamp(s.start),[m,c]=n.getTimestamp(s.end),p=e*60+a,d=i*60+r,g=u*60+o,h=m*60+c;return p<h&&g<d}static getTimestamp(t){const[s,e]=t.split(":");return[parseInt(s),parseInt(e)]}static validate(t){const[s,e]=n.getTimestamp(t.start),[a,i]=n.getTimestamp(t.end);if(a<s||a===s&&i<e)throw new Error("The second timestamp cannot denote a time earlier than the first timestamp");if(n.duration(t)<=0)throw new Error("Duration is too small");return!0}static duration(t){const[s,e]=n.getTimestamp(t.start),[a,i]=n.getTimestamp(t.end),r=s*60+e,u=a*60+i;if(u<r)throw new Error("End time cannot be earlier than start time");return(u-r)/60}static formatTimespamp(t){const[s,e]=t.split(":");return`${s.padStart(2,"0")}:${e.padStart(2,"0")}`}static equals(t,s){return t.task===s.task&&t.start==s.start&&t.end==s.end&&t.qType==s.qType}}export{n as T};
