class n{static new(s,t,e,a){return{taskName:s,start:t,end:e,qType:a}}static intersects(s,t){const[e,a]=n.getTimestamp(s.start),[i,r]=n.getTimestamp(s.end),[o,u]=n.getTimestamp(t.start),[m,c]=n.getTimestamp(t.end),p=e*60+a,d=i*60+r,g=o*60+u,h=m*60+c;return p<h&&g<d}static getTimestamp(s){const[t,e]=s.split(":");return[parseInt(t),parseInt(e)]}static validate(s){const[t,e]=n.getTimestamp(s.start),[a,i]=n.getTimestamp(s.end);if(a<t||a===t&&i<e)throw new Error("The second timestamp cannot denote a time earlier than the first timestamp");if(n.duration(s)<=0)throw new Error("Duration is too small");return!0}static duration(s){const[t,e]=n.getTimestamp(s.start),[a,i]=n.getTimestamp(s.end),r=t*60+e,o=a*60+i;if(o<r)throw new Error("End time cannot be earlier than start time");return(o-r)/60}static formatTimespamp(s){const[t,e]=s.split(":");return`${t.padStart(2,"0")}:${e.padStart(2,"0")}`}static equals(s,t){return s.taskName===t.taskName&&s.start==t.start&&s.end==t.end&&s.qType==t.qType}static aggregateDurations(s){const t={};for(const e of s)e.taskName in t||(t[e.taskName]=0),t[e.taskName]+=n.duration(e);return console.log("Calculate bins",t),t}}export{n as T};
