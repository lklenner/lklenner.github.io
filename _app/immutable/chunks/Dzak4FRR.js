class a{static new(s,t,e,n){return{taskName:s,start:t,end:e,qType:n}}static intersects(s,t){const[e,n]=a.getTimestamp(s.start),[r,i]=a.getTimestamp(s.end),[o,u]=a.getTimestamp(t.start),[m,c]=a.getTimestamp(t.end),p=e*60+n,d=r*60+i,g=o*60+u,h=m*60+c;return p<h&&g<d}static getTimestamp(s){const[t,e]=s.split(":");return[parseInt(t),parseInt(e)]}static validate(s){const[t,e]=a.getTimestamp(s.start),[n,r]=a.getTimestamp(s.end);if(n<t||n===t&&r<e)throw new Error("The second timestamp cannot denote a time earlier than the first timestamp");if(a.duration(s)<=0)throw new Error("Duration is too small");return!0}static duration(s){const[t,e]=a.getTimestamp(s.start),[n,r]=a.getTimestamp(s.end),i=t*60+e,o=n*60+r;if(o<i)throw new Error("End time cannot be earlier than start time");return(o-i)/60}static formatTimespamp(s){const[t,e]=s.split(":");return`${t.padStart(2,"0")}:${e.padStart(2,"0")}`}static formatDecimalTime(s){const t=Math.floor(s),e=Math.round((s-t)*60);return`${String(t).padStart(2,"0")}:${String(e).padStart(2,"0")}`}static equals(s,t){return s.taskName===t.taskName&&s.start==t.start&&s.end==t.end&&s.qType==t.qType}static aggregateDurations(s){const t={};for(const e of s)e.taskName in t||(t[e.taskName]=0),t[e.taskName]+=a.duration(e);return console.log("Calculate bins",t),t}}export{a as T};
